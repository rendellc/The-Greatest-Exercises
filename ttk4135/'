import numpy as np

def compose(f1, f2):
    return lambda t: f1(f2(t))

def update(func, xs):
   
    x_centroid = sum(xs[:~0]) 
    n = xs.shape[1]
    x_bar = lambda t: x_centroid + t*(xs[~0] - x_centroid)
    f_reflect = compose(func, x_bar)

    fs = list(map(func, xs)) # shouldnt need to evaluate all, implement lazy evaluation

    outside_contract = f_reflect(-1.0/2.0)
    inside_contract = f_reflect(-1.0/2.0)

    f_reflect_one = f_reflect(-1.0)
    if fs[0] <= f_reflect_one and f_reflect_one < fs[~1]:
        #print("Reflection point is neither best nor worst in the new simplex")
        xs[~0] = f_reflect_one
        return xs
    elif f_reflect_one < fs[0]:
        #print("Reflected point is better than the current best try to go further along this direction")
        f_reflect_two = f_reflect(-2.0)
        if f_reflect_two < f_reflect_two:
            xs[~0] = f_reflect_two
        else:
            xs[~0] = f_reflect_one

        return xs
    elif f_reflect_one >= fs[~1]:
        #print("Reflected point is still worse than xn; contract")
        if fs[~1] <= f_reflect_one < fs[~0]:
            #print("","Try outside contraction")
            f_reflect_onehalf = f_reflect(-1.0/2.0)
            if f_reflect_onehalf < f_reflect_one:
                xs[~0] = f_reflect_onehalf
                return xs
        else:
            #print("", "Try inside contraction")
            f_reflect_onehalf = f_reflect(1.0/2.0)
            if f_reflect_onehalf < fs[~0]:
                xs[~0] = f_reflect_onehalf
                return xs

        #print("Neither outside nor inside was acceptable, shrinking simplex toward x1")
        for i in range(1,n+1):
            xs[i] = 0.5*xs[1] + 0.5*xs[i]

        return xs
    else:
        print("NOOOOOOO")


if __name__ == "__main__":
    print("Main")
    func = lambda x: x[0]**2 + x[1]**2 + x[2]**2 + x[3]**2

    xs = np.random.random((5,4))
    for x in xs:
        print(x, func(x))

    xs = sorted(xs, key=func)
    xs = np.array(xs)


    while True:
        print(best, prev_best)
        xs = update(func, xs)
        x_centroid = sum(xs[:~0]) 
        prev_best = best
        best = func(xs[0])

    
